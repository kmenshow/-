# Отчет по лабораторной работе №1. Работа с git

## Выполнил: Меньшов Константин Эдуардович НФИбд-02-19 1032191342

# Задание
    Необходимо ознакомиться с основными возможностями git, а также научиться работать с markdown

# Выполнение
### 1.1 Подготовка
Для начала мне нужно подготовить окружение. Для этого я устанавливаю имя и e-mail пользователя, от которого будет вестись работа. Также выставляем параметры для корректной работы с текстовыми файлами (в зависимости от типа ОС). У меня все эти параметры уже были установлены, как и сам git.

![img_1](photo/img_1.png "settings")

### 1.2 Создание проекта
Создаю проект hello, в котором создаю файл hello.html. Записываю в этот файл какой-либо текст. После этого делаю данный проект репозиторием, добавляю изменения в индекс и делаю коммит. Проверяю текущее состояние репозитория. 

![img_2](photo/img_2.png "project")

### 1.3  Внесение изменений
Изменим наш текст. Проверим состояние репозитория - изменения не добавлены в индекс. 

![img_3](photo/img_3.png "changes")

### 1.4  Индексация изменений
Добавляем и смотрим снова. После этого совершаем коммит, только в этот раз без параметра -m, т.е. пишем комментарий в текстовом редакторе. 

![img_4](photo/img_4.png "commit")

![img_5](photo/img_5.png "commit")

Изменим наш текст еще раз, добавим изменения в индекс.  После этого снова изменяем текст и смотрим состояние - наш файл отмечем дважды - одно изменение в индексе и готово к коммиту, второе - нет. 

![img_6](photo/img_6.png "two changes")

Делаем коммит и смотрим статус - есть новые изменения. Добавляем оставшиеся изменения в индекс и проверяем статус. После совершаем коммит.

![img_7](photo/img_7.png "commit")

Просматриваем совершенные изменения. Выберем какой-либо предыдущий коммит, запомним его хэш-код и с помощью команды checkout и хэша скопируем его в рабочий репозиторий. Проверим содержимое нашего файла на данном коммите - оно отличается от текущего. 

![img_8](photo/img_8.png "logs")

Вернемся к последней (текущей) версии при помощи git checkout master и проверим содержимое файла для достоверности.

![img_9](photo/img_9.png "checkout")

Создадим тег для текущей версии страницы hello - назовем его v1. Перейдем на предыдущую версию изменений и проверим содержимое файла. Установим тег и на эту версию - v1-beta. 
Просматриваем все теги разными способами. 

![img_10](photo/img_10.png "show_tegs")

![img_11](photo/img_11.png "show_tegs")

### 1.5 Отмена локальных изменений (до индексации)
Перейдем в последнюю версию изменений, и изменим наш файл. Мы нонимаем, что это изменение нам не нужно. Смотрим состояние - файл изменен. 

Для отмены изменений воспользуемся git checkout hello.html, смотрим - изменений нет. 

![img_12](photo/img_12.png "cancel_changes")

### 1.6 Отмена проиндексированных изменений (перед коммитом)
Воссоздаем предыдущую ситуацию, только в этот раз добавим изменения в индекс. 

![img_13](photo/img_13.png "cancel_index_changes")

Чтобы отменить нежелательные изменения в этом случае, воспользуемся командой git reset HEAD hello.html, а затем тем же алгоритмом, что и на предыдущем шаге. 

### 1.7  Отмена коммитов
Теперь изменим файл и сделаем его нежелательный коммит. Для его отмены сделаем еще один коммит, отменяющий предыдущий. Проверяем логи. 

![img_14](photo/img_14.png "cancel_commit")

### 1.8 Удаление коммиттов из ветки
Мы видим, что хоть мы и отменили коммит, в логах они остались - удалим их при помощи сборщика мусора. Отметим эту ветку тегом oops. Сбросим коммит к предыдущему тегу v1 и проверим логи.

![img_15](photo/img_15.png "remove_commit")

Даже после этого удаленные коммиты можно увидеть в расширенных логах.  

![img_16](photo/img_16.png "remove_commit")

### 1.9 Удаление тега oops

Удалим тег oops и проверим историю коммитов - сейчас там нет нежелательных коммитов. 

![img_17](photo/img_17.png "remove oops")

### 1.10 Внесение изменений в коммиты
Добавил в страницу комментарии автора и закоммитил

![img_18](photo/img_18.png "comment")

Далее, еще изменил текст и чтобы не создавать отдельный коммит, я изменил предыдущий

![img_19](photo/img_19.png "commit change")

И в истории можно увидеть, что коммит только один

![img_20](photo/img_20.png "commit change log")

### 1.11 Перемещение файлов
Перемещаю файл hello.html в каталог lib

![img_21](photo/img_21.png "mv")

### 1.12 Второй способ перемещения файлов
Посмотрел второй вариант перемещения файлов, который идентичен предыдущему пункту.

![img_22](photo/img_22.png "mv_2")

### 1.13 Подробнее о структуре
Добавил файл index.html и сделал коммит

![img_23](photo/img_23.png "add touch")

### 1.14 Git внутри: Каталог .git
Просмотрел каталог .git, базу данных объектов, состоющую из каталогов с именем из двух символов, и прошелся по этим каталогам.

![img_24](photo/img_24.png "structure .git")

Также просмотрел файл конфигурации, ветки и теги, и файл HEAD.

### 1.15 Работа непосредственно с объектами git
Выведем на экран последний коммит в репозитории командой git log —max-count=1, вывел последний коммит с помощью хэша, затем вывел дерево каталогов, ссылку на который взял в коммите. После этого вывел каталог lib, файл hello.html

![img_25](photo/img_25.png "git_objects")
![img_26](photo/img_26.png "git_object")

### 1.16 Создание ветки
Создал новую ветку style, добавил файл стилей style.css, изменил основную страницу hello.html, чтобы использовать стили, обновил файл index.html, чтобы он тоже использовал style.css.

![img_27](photo/img_27.png "branch")

![img_28](photo/img_28.png "change branch")
![img_29](photo/img_29.png "change branch")

### 1.17 Навигация по веткам
Переключился на ветку master, просмотрел файл hello.html без стилей, затем вернулся к ветке style и просмотрел файл hello.html, в котором есть стили.

![img_30](photo/img_30.png "change master")
### 1.18 Изменения в ветке master
Создал файл README.md и записал туда строку

### 1.19 Коммит изменений README.md в ветку master
Сделал коммит изменений README.md, просмотрел текущие ветки и их отличия лог-командой git log —graph —all. Команда вызывает построение дерева коммитов с помощью простых ASCII символов, а -all означает, что мы видим все ветки.

![img_31](photo/img_31.png "commit README")

![img_32](photo/img_32.png "commit README")

### 1.20 Слияние
Вернулся к ветке style и выполнил слияние master с style. 

![img_33](photo/img_33.png "merge")
![img_34](photo/img_34.png "merge")

### 1.21 Создание конфликта
Вернулся в ветку master и внес изменения в файл hello.html, сделал коммит. Затем просмотрел логи веток, последнее изменение в master конфликтует с некоторыми изменениями в style.

![img_35](photo/img_35.png "create_conflict")

![img_36](photo/img_36.png "create_conflict")

### 1.22 Разрешение конфликтов
Вернулся к ветке style и попытался объединить ее с новой веткой master, возник конфликт. Открыл файл hello.html и вучную разрешил конфликт. Затем сделал коммит решения конфликта.
![img_37](photo/img_37.png "fix_conflict")
![img_38](photo/img_38.png "fix_conflict")
![img_39](photo/img_39.png "fix_conflict")
![img_40](photo/img_40.png "fix_conflict")

### 1.23 Сброс ветки style
Вернулся к ветке style в точку перед слиянием с master, нашел последний коммит перед слиянием и сбросил ветку style к этому коммиту. Затем проверил ветку, в логах нет коммитов слияний.

![img_41](photo/img_41.png "reset_style")
![img_42](photo/img_42.png "reset_style")

### 1.24 Сброс ветки master
Вернулся к ветке master перед внесением конфликтующих изменений. Нашел коммит "Added README" и сбросил ветку к этому коммиту.
![img_43](photo/img_43.png "reset_master")
![img_44](photo/img_44.png "reset_master")

### 1.25 Перебазирование
В данном пункте я использую команду rebase, вместо команды merge. И хочу перенести изменения из ветки master в ветку style.

![img_45](photo/img_45.png "rebase")

Конечный результат перебазирования очень похож на результат слияния.
Однако, дерево коммитов значительно отличается. Дерево ком-
митов ветки style было переписано таким образом, что ветка master является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.
Рекомендуется использовать git
rebase для кратковременных, локальных веток, а слияние для веток в публичном
репозитории.
### 1.26 Слияние в ветку master
Я поддерживал соответствие ветки style с веткой master,
теперь солью изменения style в ветку master.

![img_46](photo/img_46.png "merge")

Теперь ветки style и master идентичны.


### 1.27 Клонирование репозиториев
Для клонирования репозиториев нужно перейти в рабочий каталог и с помощью комманды clone создать clone репозитория

![img_47](photo/img_47.png "clone")

### 1.28 Просмотр клонированного репозитория
Для этого перейдём в клонированный репозиторий и просмотрим его.

![img_48](photo/img_48.png "clone rep")

Далее просмотрим историю клонированного репозитория. Она совпадает с исходной

### 1.29 Что такое origin?
Выполним команду git remote.

![img_49](photo/img_49.png "remote")

Мы видим, что клонированный репозиторий знает об имени по умолчанию
удаленного репозитория.
Выполним команду git remote show origin.
Удалённые репозитории могут с тем же
успехом указывать на репозиторий на той же машине. Нет ничего особенного
в имени «origin», однако существует традиция использовать «origin» в качестве
имени первичного централизованного репозитория (если таковой имеется).

### 1.30 Удаленные ветки
Для того, чтобы увидеть все ветки, в том числе удалённые, я выполнил следующую команду: git branch -a

![img_50](photo/img_50.png "branch -a")

### 1.31 Изменение оригинального репозитория
Я внес некоторые изменения в оригинальный репозиторий, чтобы затем попытаться извлечь и слить изменения из удаленной ветки в текущую

![img_51](photo/img_51.png "README")

Для того, чтобы извлечь изменения я воспользовался командой git fetch

![img_52](photo/img_52.png "fetch")

На данный момент в клонированном репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.
Команда git fetch будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в
локальных ветках.
Можно посмотреть файл README.md и увидеть, что он не изменился

![img_53](photo/img_53.png "logs")
![img_54](photo/img_54.png "README check")

### 1.32 Слияние извлеченных изменений
Для начала солью извлеченные изменения в локальную ветку master командой merge

![img_60](photo/img_60.png "merge origin/master")

Проверяю файл README и вижу, что он изменился
Объединение fetch и merge в одну команду: pull

### 1.33 Добавление ветки наблюдения
Добавляю локальную ветку, которая отслеживает удаленную ветку
Для этого:

![img_55](photo/img_55.png "track branch")

### 1.34 Чистые репозитории
Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что вы будете использовать
его как рабочую директорию, поэтому вместе с файлами проекта в актуальной
версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске, а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый
репозиторий».

### 1.35 Создайте чистый репозиторий
Для создания чистого репозитория воспользуюсь командой

![img_56](photo/img_56.png "clone —bare")

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями

### 1.36 Добавление удаленного репозитория
Добавляем репозиторий hello.git к нашему оригинальному репозиторию.

![img_57](photo/img_57.png "remote add")

### 1.37 Отправка изменений
Для этого я отредактировал файл README.md и сделал коммит
Затем отправил изменения в общий репозиторий.

![img_58](photo/img_58.png "push")

### 1.38 Извлечение общих изменений
Для этого я выполнил ряд комманд

![img_59](photo/img_59.png "branch")

# Вывод
    Ознакомился с основными возможностями git, а также научиться работать с markdown